# Project: The name of the Azure DevOps Project to which we are exporting our solution.
# Repo: The name of the Azure DevOps Repo to which we are exporting our solution.
# Branch: The name of the Azure DevOps Branch in the Repo above to which we are exporting our solution.
# CommitMessage: The commit message for this commit.
# Email: The email of the user performing the commit.
# .serviceConnection: The name of the service connection to Power Platform from which we'll be pulling the solution.
# SolutionName: The name of the solution being exported (i.e. Not the Display Name).
# UserName: The Display name of the user performing the commit.
parameters:
- name: project
  type: string
  default: ''
- name: repo
  type: string
  default: ''
- name: branch
  type: string
  default: ''
- name: commitMessage
  type: string
  default: ''
- name: email
  type: string
  default: ''
- name: serviceConnection
  type: string
  default: ''
- name: solutionName
  type: string
  default: ''
- name: userName
  type: string
  default: ''
- name: buildType
  type: string
  default: 'Both'
  values:
  - Both
  - Managed
  - Unmanaged

steps:
# Set pipeline vars for tools paths.
- template: set-tools-paths.yml

# Restore PowerShell Module dependencies if available in cache
# https://docs.microsoft.com/en-us/azure/devops/pipelines/release/caching?view=azure-devops
- task: Cache@2
  displayName: Cache Powershell Modules
  inputs:
    key:  restoremodules | "$(powerPlatformToolsSubPath)" | $(Build.SourcesDirectory)/Pipelines/Templates/install-powershell-modules.yml
    path: $(powerPlatformToolsPath)
    cacheHitVar: powerPlatformToolsPath_IsCached

- ${{ if ne(variables.powerPlatformToolsPath_IsCached, 'true') }}:
  - template: install-powershell-modules.yml

# Configure email/name and checkout git branch
- script: |
   git config user.email "${{parameters.email}}"
   git config user.name "${{parameters.userName}}"
   git checkout origin/${{parameters.branch}} --track
  workingDirectory: $(Build.SourcesDirectory)
  displayName: 'Initialize Git'

- task: microsoft-IsvExpTools.PowerPlatform-BuildTools.tool-installer.PowerPlatformToolInstaller@0
  displayName: 'Install Power Platform Build Tools'

# Before exporting the solution, publish solution customizations to ensure all the changes are exported
- task: microsoft-IsvExpTools.PowerPlatform-BuildTools.publish-customizations.PowerPlatformPublishCustomizations@0
  displayName: 'Publish Customizations'
  inputs:
    authenticationType: PowerPlatformSPN
    PowerPlatformSPN: '${{parameters.serviceConnection}}'

# Export both unmanaged and managed to put into source control
- task: microsoft-IsvExpTools.PowerPlatform-BuildTools.export-solution.PowerPlatformExportSolution@0
  displayName: 'Export Unmanaged Solution'
  inputs:
    authenticationType: PowerPlatformSPN
    PowerPlatformSPN: '${{parameters.serviceConnection}}'
    SolutionName: '${{parameters.solutionName}}'
    SolutionOutputFile: '$(Build.ArtifactStagingDirectory)\${{parameters.solutionName}}.zip'
  condition: or(eq('${{parameters.buildType}}', 'Both'), eq('${{parameters.buildType}}', 'Unmanaged'))

- task: microsoft-IsvExpTools.PowerPlatform-BuildTools.export-solution.PowerPlatformExportSolution@0
  displayName: 'Export Managed Solution'
  inputs:
    authenticationType: PowerPlatformSPN
    PowerPlatformSPN: '${{parameters.serviceConnection}}'
    SolutionName: '${{parameters.solutionName}}'
    SolutionOutputFile: '$(Build.ArtifactStagingDirectory)\${{parameters.solutionName}}_managed.zip'
    Managed: true
  condition: or(eq('${{parameters.buildType}}', 'Both'), eq('${{parameters.buildType}}', 'Managed'))

# Unpack contents of solution to make the contents source control friendly 
- task: microsoft-IsvExpTools.PowerPlatform-BuildTools.unpack-solution.PowerPlatformUnpackSolution@0
  displayName: 'Power Platform Unpack Solution'
  inputs:
    SolutionInputFile: '$(Build.ArtifactStagingDirectory)\${{parameters.solutionName}}.zip'
    SolutionTargetFolder: '$(Build.SourcesDirectory)\Solutions\${{parameters.solutionName}}'
    SolutionType: '${{parameters.buildType}}'

# TEMPORARY until SolutionPackager supports formatting json files on unpack we
# update all the json files to be pretty-print / formatted so they are easier to read in source control.
# This also makes it easier to read changes from one commit to another
- powershell: |
   Get-ChildItem -Path "$(Build.SourcesDirectory)\Solutions\${{parameters.solutionName}}" -Recurse -Filter *.json | 
   ForEach-Object {
    #skip canvas app folder because canvas team already handles this for canvas unpack
     if(-not $_.FullName.Contains('CanvasApps')) {
       Write-Host $_.FullName
       $formatted = jq . $_.FullName --sort-keys
       $formatted | Out-File $_.FullName -Encoding UTF8
     }
   }
   del $(Build.ArtifactStagingDirectory)\${{parameters.solutionName}}.zip
   del $(Build.ArtifactStagingDirectory)\${{parameters.solutionName}}_managed.zip
  displayName: 'Format JSON files'
  enabled: true

- template: export-configuration-data.yml
  parameters:
    environmentUrl: $(EnvironmentUrl)
    environmentName: $(EnvironmentName)

# We'll store configuration data as artifacts on the build pipeline to be used during deployment. This includes configuration data created via Configuration data migration tool and deploymentSettings.json and customDeploymentSettings.json 
- powershell: |
    $path = "$(ConfigurationMigrationFilePath)"
    if(Test-Path $path) {
        $extract = @{
            Path = $path
            DestinationPath = '$(Build.SourcesDirectory)/Config/Data'
        }
        Expand-Archive @extract
    }
  displayName: 'Archive Configuration Migration Data'
  enabled: true

- powershell: |
    git add --all
  workingDirectory: $(Build.SourcesDirectory)
  displayName: 'Add Changes to Git Branch'

# Commit all changes to Git branch. If there are no changes we want to warn the user that there was nothing to commit. As this could mean there was a user error involved.
- powershell: |
    $gitStatus = iex "git status --porcelain"
    if ($gitStatus) {
        git commit -m "${{parameters.commitMessage}}"
    }
    else {
        Write-Host "##vso[task.logissue type=warning]There is nothing to commit. No changes have been made since the previous commit. If this is unexpected make sure your changes have been published before committing again."
        exit 1;
    }
  workingDirectory: $(Build.SourcesDirectory)
  displayName: 'Commit Changes to Git Branch'
  continueOnError: true
  
- script: |
   git -c http.extraheader="AUTHORIZATION: bearer $(System.AccessToken)" push origin ${{parameters.branch}}
  workingDirectory: $(Build.SourcesDirectory)
  displayName: 'Push to $(Branch) Remote Branch'
  condition: succeeded()