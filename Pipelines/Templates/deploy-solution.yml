# This is a deployment template referenced from build-deploy-Solution.yml

# build-deploy-Solution.yml calls this template twice, passing different connection information for test vs prod
parameters:
- name: serviceConnection
  type: string
- name: importUnmanaged
  type: string
  default: 'false'
- name: overwriteUnmanagedCustomizations
  type: string
  default: 'true'
- name: skipBuildToolsInstaller
  type: string
  default: 'false'

steps:
# Set pipeline vars for tools paths.
- template: set-tools-paths.yml

# Restore PowerShell Module dependencies if available in cache
# https://docs.microsoft.com/en-us/azure/devops/pipelines/release/caching?view=azure-devops
- task: Cache@2
  displayName: Cache Powershell Modules
  inputs:
    key:  restoremodules | "$(powerPlatformToolsSubPath)" | $(Build.SourcesDirectory)/Pipelines/Templates/install-powershell-modules.yml
    path: $(powerPlatformToolsPath)
    cacheHitVar: powerPlatformToolsPath_IsCached

- task: microsoft-IsvExpTools.PowerPlatform-BuildTools.tool-installer.PowerPlatformToolInstaller@0
  displayName: 'Install Power Platform Build Tools'
  condition: and(succeeded(), eq('${{parameters.skipBuildToolsInstaller}}', 'false'))

- template: install-powershell-modules.yml

# Other tasks, in this pipeline need to know if the solution already exists. Setting it for future use.
- template: set-solution-exists.yml
  parameters:
    serviceConnection: '${{parameters.serviceConnection}}'

# Get the solution package from artifact uploaded by the build pipeline
- task: DownloadPipelineArtifact@2
  displayName: 'Download Build Pipeline Artifact'

- powershell: |
   $artifactDropPath = '$(Pipeline.Workspace)/drop/'
   If (Test-Path -Path "$(Pipeline.Workspace)/buildPipeline/drop")
   {
       $artifactDropPath = "$(Pipeline.Workspace)/buildPipeline/drop/"
   }
   Write-Host "##vso[task.setVariable variable=ArtifactDropPath]$artifactDropPath"
  displayName: 'Get artifact drop path'

# Set paths to deployment settings
- template: set-deployment-configuration-paths.yml
  parameters:
    environmentName: $(EnvironmentName)

# If called from import-unmanaged-to-dev-environment.yml, this task will run to deploy an unmanaged solution
- task: microsoft-IsvExpTools.PowerPlatform-BuildTools.import-solution.PowerPlatformImportSolution@0
  displayName: 'Import Unmanaged Solution'
  inputs:
    authenticationType: PowerPlatformSPN
    PowerPlatformSPN: '${{parameters.serviceConnection}}'
    SolutionInputFile: '$(UnmanagedSolutionPath)'
    PublishWorkflows: true
    UseDeploymentSettingsFile: $(UseDeploymentSettings)
    DeploymentSettingsFile: $(DeploymentSettingsPath)
  condition: and(succeeded(), eq('${{parameters.importUnmanaged}}', 'true'))

- powershell: |
    $managedSolutionPath = ''
    $artifactDropPath = "$(Pipeline.Workspace)/buildPipeline/drop/"
    #Attempt to find the managed solution in the build pipeline drop if build and deploy are seperate pipelines
    Get-ChildItem -Path "$(ArtifactDropPath)" -Filter "$(SolutionName)*.zip" | 
    ForEach-Object {
        If ($_.FullName.Contains("_managed")) 
        { 
            $managedSolutionPath = $_.FullName 
        }
    }
    Write-Host "##vso[task.setVariable variable=ManagedSolutionPath]$managedSolutionPath"
  displayName: 'Get managed solution zip path'
  condition: and(succeeded(), ne('${{parameters.importUnmanaged}}', 'true'))

# If the TriggerSolutionUpgrade variable is false, then import the solution as an Update
- task: microsoft-IsvExpTools.PowerPlatform-BuildTools.import-solution.PowerPlatformImportSolution@0
  displayName: 'Import Managed Solution as Update'
  inputs:
    authenticationType: PowerPlatformSPN
    PowerPlatformSPN: '${{parameters.serviceConnection}}'
    SolutionInputFile: $(ManagedSolutionPath)
    PublishWorkflows: true
    OverwriteUnmanagedCustomizations: ${{parameters.overwriteUnmanagedCustomizations}}
    UseDeploymentSettingsFile: $(UseDeploymentSettings)
    DeploymentSettingsFile: $(DeploymentSettingsPath)
  condition: and(succeeded(), ne('${{parameters.importUnmanaged}}', 'true'), or(eq(variables['setTriggerSolutionUpgrade.TriggerSolutionUpgrade'], 'false'), eq(variables['SolutionExists'], 'false')))

# If the TriggerSolutionUpgrade variable is true, then import the solution as an Upgrade, staging it as a holding solution, so we can apply a solution Upgrade.
# Doing this will ensure that items removed from the solution in development are also removed from the solution in the target environment after the Upgrade is applied.
- task: microsoft-IsvExpTools.PowerPlatform-BuildTools.import-solution.PowerPlatformImportSolution@0
  displayName: 'Import Managed Solution as Upgrade'
  inputs:
    authenticationType: PowerPlatformSPN
    PowerPlatformSPN: '${{parameters.serviceConnection}}'
    SolutionInputFile: $(ManagedSolutionPath)
    HoldingSolution: true
    OverwriteUnmanagedCustomizations: ${{parameters.overwriteUnmanagedCustomizations}}
    UseDeploymentSettingsFile: $(UseDeploymentSettings)
    DeploymentSettingsFile: $(DeploymentSettingsPath)
  condition: and(succeeded(), ne('${{parameters.importUnmanaged}}', 'true'), eq(variables['setTriggerSolutionUpgrade.TriggerSolutionUpgrade'], 'true'), eq(variables['SolutionExists'], 'true'))

# NOTE: Sometimes you need to perform intermediary steps between staging the upgrade and applying it.  
# An example would be moving data from one entity to another before deleting the entity.
# You would add steps to your pipeline here to accomplish this. 

# If the TriggerSolutionUpgrade variable is true,then apply the solution Upgrade.
- task: microsoft-IsvExpTools.PowerPlatform-BuildTools.apply-solution-upgrade.PowerPlatformApplySolutionUpgrade@0
  inputs:
    authenticationType: 'PowerPlatformSPN'
    PowerPlatformSPN: '${{parameters.serviceConnection}}'
    SolutionName: '$(SolutionName)'
    AsyncOperation: true
  condition: and(succeeded(), eq(variables['setTriggerSolutionUpgrade.TriggerSolutionUpgrade'], 'true'), eq(variables['SolutionExists'], 'true'))

- task: microsoft-IsvExpTools.PowerPlatform-BuildTools.publish-customizations.PowerPlatformPublishCustomizations@0
  displayName: 'Power Platform Publish Customizations '
  inputs:
    authenticationType: PowerPlatformSPN
    PowerPlatformSPN: '${{parameters.serviceConnection}}'
  condition: and(succeeded(), eq('${{parameters.importUnmanaged}}', 'true'))
  # Only publish customizations for when importing unmanaged solutions into a dev environment.

- template: import-configuration-data.yml
  parameters:
    serviceConnection: '${{parameters.serviceConnection}}'
